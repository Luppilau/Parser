%{
open FM4FUNTypesAST
%}

// Tokens
%start start
%token <float> NUM
%token <string> ID 
%token <boolean> BOOL
%token TIMES DIV PLUS MINUS POW LPAR RPAR
%token TRUE FALSE EQUAL LT GT SCOLON COLON RSQBR LSQBR DASH AND OR EXCL 
%token SKIP IF FI DO OD EOF

// Specify precedence and associativity of operators
// Precedence is given by the order (from low to high)
%left PLUS MINUS
%left TIMES DIV
%right POW

%left OR
%left AND
%left EXCL

%right LSQBR RSQBR SCOLON

// We specify the return type of each of then non-terminal symbols
%type <expr> start
%type <expr> command

// Grammar productions
%%

// The first production in "formal" notation is
// start -> expression
// here written:
start: command EOF             { $1 }

// Note that we need to insert an End-Of-File (EOF)
// The code annotation { $1 } specifies that parsing with this production
// returns whatever parsing the expression returns: $1 is the result of parsing
// the first component of the production (i.e. expression)

// The productions for expressions are like in the grammar we saw in class
// written in the yacc format:

// expression:
//   | expression TIMES expression   { TimesExpr($1,$3) }
//   | expression DIV expression     { DivExpr($1,$3) }
//   | expression PLUS expression    { PlusExpr($1,$3) }
//   | expression MINUS expression   { MinusExpr($1,$3) }
//   | expression POW expression     { PowExpr($1,$3) }
//   | PLUS expression               { UPlusExpr($2) }
//   | MINUS expression              { UMinusExpr($2) }
//   | NUM                           { Num($1) }
//   | LPAR expression RPAR          { $2 }

command:
  | ID COLON EQUAL arithmetic                         { Assignment($1, $4) }
  | ID LSQBR arithmetic RSQBR COLON EQUAL arithmetic  { ArrAssignment($1, $3, $7)}
  | SKIP                                              { Skip }
  | command SCOLON command                            { Chain($1,$3) }
  | IF guarded FI                                     { If($2) }
  | DO guarded OD                                     { Do($2) }

guarded:
  | boolean DASH GT command           { Match($1, $4) }      
  | guarded LSQBR RSQBR guarded       { Conc($1, $4) }      

arithmetic:
  | NUM                               { n($1) }
  | ID                                { x($1) }
  | ID LSQBR arithmetic RSQBR         { ArrVal($1, $3)}
  | arithmetic PLUS arithmetic        { Add($1,$3) }
  | arithmetic MINUS arithmetic       { Sub($1,$3) }
  | arithmetic TIMES arithmetic       { Prod($1,$3) }
  | arithmetic DIV arithmetic         { Div($1,$3) }
  | MINUS arithmetic                  { Neg($2) }
  | arithmetic POW arithmetic         { Exp($1,$3) }
  | LPAR arithmetic RPAR              { $2 }

boolean: 
  | TRUE                              { Bool(true) }
  | FALSE                             { Bool(false) }
  | boolean AND boolean               { SingleAnd($1, $3) }
  | boolean OR boolean                { SingleOr($1, $3) }
  | boolean AND AND  boolean          { DoubleAnd($1, $4) }
  | boolean OR OR boolean             { DoubleOr($1, $4) }
  | EXCL boolean                      { Neg($2) }
  | arithmetic EQUAL arithmetic       { Eq($1, $3) }
  | arithmetic EXCL EQUAL arithmetic  { Neq($1, $4) }
  | arithmetic GT arithmetic          { Gt($1, $3) }
  | arithmetic GT EQUAL arithmetic    { Geq($1, $4) }
  | arithmetic LT arithmetic          { Lt($1, $3) }
  | arithmetic LT EQUAL arithmetic    { Leq($1, $4) }
  | LPAR arithmetic RPAR              { $2 }


// Again, the code annotation specifies the result of parsing
// For example { TimesExpr($1,$3) } specifies that parsing with the production
// returns the value TimesExpr($1,$3), where $i is the result of parsing
// component i in the production (in this case the lhs and rhs operands)

%%
